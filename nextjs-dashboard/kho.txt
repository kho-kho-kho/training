--------- Chapter 1: Getting Started

/app: Contains all the routes, components, and logic for your application, this is where you'll be mostly working from.
/app/lib: Contains functions used in your application, such as reusable utility functions and data fetching functions.
/app/ui: Contains all the UI components for your application, such as cards, tables, and forms. To save time, we've pre-styled these components for you.
/public: Contains all the static assets for your application, such as images.
Config Files: You'll also notice config files such as next.config.ts at the root of your application. Most of these files are created and pre-configured when you start a new project using create-next-app. You will not need to modify them in this course.

mockAPI for placeholder data (mock REST calls) if db or real API not ready

If you're a TypeScript developer for better type-safety, we recommend
Prisma (postgres db manager) or Drizzle ORM (object relational mapping)
which automatically generates types based on your database schema.

Next.js also comes with a TypeScript plugin for your code editor, to help with auto-completion and type-safety.
To add TypeScript to an existing project, rename a file to .ts / .tsx.
Run next dev and next build to automatically install the necessary dependencies
and add a tsconfig.json file with the recommended config options.

install project packages
>npm i
start dev server (http://localhost:3000)
>npm run dev

--------- Chapter 2: CSS

Next.js prompts for Tailwind usage when create-next-app is used.
Tailwind package allows for styling components directly via classNames.

CSS modules (.module.css file extension) help to avoid style clashes
via automatic creation of unique class names.
Supported in Next.js via webpack and Turbopack (next dev --turbo).

clsx package allows for conditional styling of component.

Other approaches Sass, CSS-in-JS libs like emotion, styled-jsx, styled-components ..

--------- Chapter 3: Optimizing Fonts and images

Next.js downloads font files at build time and hosts with other static assets.

Static assets like images stored in /public can be referenced in code via /filename
The Image component auto-resizes, lazy-loads, and supports webp/avif formats.
Good practice to manually set width and height to prevent layout shift.

--------- Chapter 4: Creating Layouts and Pages

File-system routing uses folders to create nested routes.
Folders represent route segments that map to URL segments.
Only "page" and "route" files will ever be publicly accessible.

Page components re-render on navigation, but layouts do not.
A root layout is required for all Next.js apps and any UI added to the root
will be shared across all pages in the application.

--------- Chapter 5: Navigating Between Pages

<Link /> components used for client-side transitions (avoid page reload).
Code for Link'd routes are also prefetched when Links appear in viewport.

--------- Chapter 6: Setting Up Your database

Vercel supports GitHub repo connectivity for instant deployments.
Vercel's marketplace includes native storage solutions compatible w AWS.
Free tier includes  (very roughly) 1MM requests/mo and 100GB transfer/mo

Create Postgres db via Vercel > export credentials > seed db > test query

--------- Chapter 7: Fetching Data

Next.js uses Route Handlers for creating API endpoints.
postgres.js lib provides protection against SQL injections.
https://github.com/porsager/postgres?tab=readme-ov-file

Next.js apps use React Server Components to fetch backend data.
Server Components support js Promises and run entirely on backend.

--------- Chapter 8: Static and Dynamic Rendering

Static rendering happens on server at build/deploy or during data revalidation.
Prerendered content can be cached and globally distributed for speed, and
makes it easier for search engine crawlers to index for improved SEO.

With dynamic rendering your app is only as fast as your slowest data fetch.

--------- Chapter 9: Streaming

loading.tsx allows you to create a fallback UI while dynamic page content loads.
Static rendered components like <SideNav> are shown immediately.
User can navigate away without waiting for page to load (interruptable navigation)

Route groups allow you to organize files into logical groups using () folders.
Any folder name surrounded by parens won't be included in the URL path.

React Suspense components allow rendering to be deferred for individual components.

Streaming whole pages via loading.tsx is easy, but slow loading components
can cause the entire page as a whole to load slow.
Every single component can be streamed independently, but can create a "popping"
visual into the screen which may be jarring to user.
Wrapper components allow for a "staggering" effect by separating page sections.

--------- Chapter 10: Adding Search and Pagination

Debouncing limits the rate at which a function can fire IE: want to avoid
kicking off a database search request every time user types in single char.
> npm i use-debounce

useSearchParams, usePathname, and useRouter are helpful Next.js client hooks
used to implement search functionality.
searchParams can be used to construct URLSearchParams which allows for
manipulation of URL query parameters and useRouter.replace enables navigation.

--------- Chapter 11: Mutating Data

React Server Actions in a 'use server' file that are ultimately not used in any
client/server component(s) will be auto-excluded from the final app bundle.
Server Actions can also be written directly inside server components by adding
"use server" inside of the function.
SAs allow for "progressive enhancement" IE: users can interact w forms even if
the client-side JavaScript hasn't loaded for whatever reason.

Zod is a TypeScript-first validation lib that helps handle type validation.

Next.js has a function revalidatePath which clears a cached route segment from
the user's browser, and triggers a new request for server data. This is needed
when creating/updating items.

--------- Chapter 12: Handling Errors
